/**
 * This header contains the declaration of the Approxumate Message-Passing (AMP) class along with it's member variables and methods 
 */
#ifndef AMP_H
#define AMP_H

#include <iostream>           // Standard IO  
#include <vector>            // Vector object to store the algorithm vectors 
#include <random>           // Generate random numbers
#include <algorithm>       // Operations on C++ containers
#include <cblas.h>        // cblas for optimized linear algebra operations
#include <iomanip>       // Used for IO manipulation 
#include <cassert>      // Assert expression used to make sure the section length and size are powers of 2 
#include <chrono>      // Used to time the algorithm  

#define data_t double // Use double precision for the results  

/**
 * AMP class 
 */
class AMP
{

public:
    int L;      // Number of sections of the sparse superposition code 
    int B;      // Section size of the sparse superposition code
    int N;      // Size of the flattened sparse code (N=L*B). Number of columns of the design/coding matrix F
    int M;      // Size of the codeword y (corresponds also to the number of rows of the design/coding matrix F)
    data_t c;   // Power allocation which corresponds to the value of the non-zeros element per section 
    data_t r;   // Communication rate 
    data_t snr; // Signla to noise ratio
    data_t std_dev; // Standard deviation of the Gaussian Channel 
    
    std::vector<data_t> code_messgae; // Vector to store the code message 
    
    std::vector<data_t> F; // Coding matrix with normal random enteries with  mean  0 and standard deviation 1/sqrt(L) 
    
    std::vector<data_t> codeword; // Corrupted code word generated by multiplying the message with the coding matrix
                                 // and adding the channel noise  

    AMP(const int &number_of_sections,
        const int &section_size,
        const data_t &power_allocation,
        data_t const &rate,
        data_t const &signal_to_noise_ration);


    void gen_sparse_code();   // Method to generate sparse superposition code
    void gen_design_matrix(); // Generate design matrix
    void gen_codeword();      // Generate code word y
    // Printing functions
    void print_code_message() const;
    void print_design_matrix() const;
    void print_code_word() const;

    // Compute the first line of the algorithm
    void update_V(const std::vector<data_t> &v, std::vector<data_t> &V);
    void compute_onsegar(const std::vector<data_t> & omega_old, const std::vector<data_t> & V_new, const std::vector<data_t> & V_old, const std::vector<data_t> & a_old, std::vector<data_t> &omega_new);
    // Compute cavity variance
    void compute_cavity_var(const std::vector<data_t> & V_new, std::vector<data_t> &sigma_new);
    // Compute cavity mean
    void compute_cavity_mean(const std::vector<data_t> & a_old, const std::vector<data_t> & sigma_new, const std::vector<data_t> & V_new, const std::vector<data_t> & omega_new, std::vector<data_t> &cavity_mean);
    // Compute the message estimation 
    void denoise_a(const std::vector<data_t> & sigma_new, const std::vector<data_t> &, std::vector<data_t> &a_new);
    // Get the error of the estimation value 
    void denosie_v(const std::vector<data_t> & a_new, std::vector<data_t> &v_new);
    // Compute the error 
    data_t compute_dif(const std::vector<data_t> &a_new, const std::vector<data_t> &a_old);
    // Solver current immplementation just to check output of helper functions
    void amplify(std::vector<data_t> a_new, std::vector<data_t> &a_temp);
    // Compute the mean square error rate 
    data_t compute_mse(const std::vector<data_t>& a_new);
    // Compute the section error rate 
    data_t compute_ser(const std::vector<data_t> &a_temp);
    // Solver
    void solve();

private:
    // Generate random numbers
    std::random_device dv; // Random seed
    std::mt19937 gen;      // Pseudo-number generator
};



#endif // AMP_H