/**
 * This header contains the declaration of the Approxumate Message-Passing (AMP) class along with it's member variables and methods 
 * The algorithm is described here: https://arxiv.org/pdf/1403.8024
 * and in more details here: https://arxiv.org/pdf/1503.08040
 * 
 */
#ifndef AMP_H
#define AMP_H

#include <iostream>           // Standard IO  
#include <vector>            // Vector object to store the algorithm vectors 
#include <random>           // Generate random numbers
#include <algorithm>       // Operations on C++ containers
#include <iomanip>       // Used for IO manipulation 
#include <cassert>      // Assert expression used to make sure the section length and size are powers of 2 
#include <chrono>      // Used to time the algorithm  
#include<cblas.h>
#include <type_traits> // To check the data type at compile time 
typedef double data_t; // Use double precision for the results
                     // to change this cblas routine should be changed from sgemm to dgemm 
                    // in the source file 
                   // Results are not accurate with float precision using double is better  

/**
 * AMP class 
 */
template <typename T>
class AMP
{

public:
    int L;      // Number of sections of the sparse superposition code 
    int B;      // Section size of the sparse superposition code
    int N;      // Size of the flattened sparse code (N=L*B). Number of columns of the design/coding matrix F
    int M;      // Size of the codeword y (corresponds also to the number of rows of the design/coding matrix F)
    data_t c;   // Power allocation which corresponds to the value of the non-zeros element per section 
    data_t r;   // Communication rate 
    data_t snr; // Signla to noise ratio
    data_t std_dev; // Standard deviation of the Gaussian Channel 
    data_t ch_capacity; // Gaussian channel capacity 
    std::vector<data_t> code_messgae; // Vector to store the code message 
    
    std::vector<data_t> F; // Coding matrix with normal random enteries with  mean  0 and standard deviation 1/sqrt(L) 
    
    std::vector<data_t> codeword; // Corrupted code word generated by multiplying the message with the coding matrix
                                 // and adding the channel noise  

    AMP(const int &number_of_sections,
        const int &section_size,
        const data_t &power_allocation,
        data_t const &rate,
        data_t const &signal_to_noise_ration);

    // Method to generate objects that will be used in the amp decoder 
    void gen_sparse_code();    // Method to generate sparse superposition code
    void gen_design_matrix(); // Method to generate design matrix
    void gen_codeword();     // method to generate a corrupted code word y
    
    // Printing functions
    void print_code_message() const;   // Method to print the code message 
    void print_design_matrix() const; // Method to print the design matrix 
    void print_code_word() const;    // Method to print the code word 

    // Methods that will be used in the amp decoder 
    void update_V(const std::vector<data_t> &v, std::vector<data_t> &V); // Methid to update the vector V 
    // Method to compute the Onsegar term 
    void compute_onsegar(const std::vector<data_t> & omega_old, const std::vector<data_t> & V_new, const std::vector<data_t> & V_old, const std::vector<data_t> & a_old, std::vector<data_t> &omega_new);
    // Method to compute cavity variance
    void compute_cavity_var(const std::vector<data_t> & V_new, std::vector<data_t> &sigma_new);
    // Method to compute cavity mean
    void compute_cavity_mean(const std::vector<data_t> & a_old, const std::vector<data_t> & sigma_new, const std::vector<data_t> & V_new, const std::vector<data_t> & omega_new, std::vector<data_t> &cavity_mean);
    // Method to compute the message estimate  
    void denoise_a(const std::vector<data_t> & sigma_new, const std::vector<data_t> &, std::vector<data_t> &a_new);
    // Method to compute to denoise the estimated message  
    void denosie_v(const std::vector<data_t> & a_new, std::vector<data_t> &v_new);
    // Method that checks for convergence by computing the difference betwwen two consucative estimations
    data_t compute_dif(const std::vector<data_t> &a_new, const std::vector<data_t> &a_old);
    // Method to amplify the estimated message 
    void amplify(std::vector<data_t> a_new, std::vector<data_t> &a_temp);
    // Method to compute the mean square error rate 
    data_t compute_mse(const std::vector<data_t>& a_new);
    // Method to compute the section error rate 
    data_t compute_ser(const std::vector<data_t> &a_temp);
    // Method to perform amp estimation on a corrupted communication 
    void solve(const int &t_max, const data_t &ep);

private:
    // Generate random numbers
    std::random_device dv; // Random seed
    std::mt19937 gen;      // Pseudo-number generator
    data_t snr_inv;  // Inverse of the snr

};

#endif // AMP_H